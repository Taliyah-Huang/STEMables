#define RX_PIN1 A1
#define ledPin 1

uint8_t playNum = 0;
uint8_t ledCommand = 255;
uint8_t cycleCountDelay = 0;
uint8_t lastCommand = 255;
bool newVal = true;
uint8_t disconnectCount = 0;
bool disconnected = false;
uint8_t speeds[4] = {100, 50, 25, 12};
uint8_t speedVal = 50;

uint8_t totalVals1[3] = {0, 0, 99};
bool collectTotalVals1 = false;
uint8_t sameVals1 = 0;
bool valArray1 = false;
uint8_t arrayType1 = 0;
bool valSet1 = false;

int currentRead1 = 0;
uint8_t storage1 [99] = {};
uint8_t store1Count = 100;
int averages1[5] = {0, 0, 0, 0, 0};
int totalAve1 = 0;
float trueVal1 = 0.0;
uint8_t trueVals1[2] = {0, 0};
int peakVal1 = 0;
float remainder1 = 0.0;
uint8_t storeNum1 = 0;
uint8_t storeTotalVals1 = 0;

void setup() {
  pinMode(RX_PIN1, INPUT);
  pinMode(ledPin, OUTPUT);
  analogWrite(ledPin, 255);

  for (uint8_t i = 0; i < 99; i++) {
    storage1[i] = 255;
  }
}

void loop() {
  cycleCountDelay++;
  currentRead1 = analogRead(RX_PIN1);

  //Running average of analogRead values
  for (uint8_t i = 4; i > 0; i--) {
    averages1[i] = averages1[i - 1];
  }
  averages1[0] = currentRead1;

  totalAve1 = (averages1[4] + averages1[3] + averages1[2] + averages1[1] + averages1[0]) / 5;

  trueVal1 = ((float) totalAve1 / 4);

  //Round the value by 0.5
  remainder1 = (float) trueVal1 - (int) trueVal1;
  trueVal1 = (int) trueVal1;

  if (remainder1 >= 0.5) {
    trueVal1++;
  }

  if ((averages1[0] - averages1[1]) < 0 && (averages1[1] - averages1[2]) < 0 && (averages1[2] - averages1[3]) < 0 || (averages1[0] - averages1[1]) >= 0 && (averages1[1] - averages1[2]) >= 0 && (averages1[2] - averages1[3]) >= 0) {
    disconnectCount = 0;
    disconnected = false;
  } else {
    disconnectCount++;
  }

  trueVals1[1] = trueVals1[0];
  trueVals1[0] = trueVal1;

  if (trueVals1[0] <= trueVals1[1] + 2 && trueVals1[0] >= trueVals1[1] - 2) {
    sameVals1++;
  } else {
    sameVals1 = 0;
  }

  if (trueVal1 >= 240) {
    arrayType1++;
    if (arrayType1 > 5) {
      arrayType1 = 10;
      valArray1 = true;
    }
  }

  if (sameVals1 == 5) {
    peakVal1 = trueVals1[1];

    if (valArray1 == true) {
      for (uint8_t i = 0; i < 4; i++) {
        if (peakVal1 <= ((i + 4) * 10) + 2 && peakVal1 >= ((i + 4) * 10) - 2) {
          speedVal = speeds[i];
        }
      }

      if (peakVal1 <= 30 + 2 && peakVal1 >= 30 - 2) {
        collectTotalVals1 = true;
      }

      if (peakVal1 > 122 && peakVal1 < 238) {
        if (collectTotalVals1 == true) {
          storeTotalVals1++;
        } else {
          storeNum1++;
        }
      }
    }

    if (storeNum1 >= totalVals1[2]) {
      storeNum1 = 0;
    }

    if (peakVal1 <= 120 + 2 && peakVal1 >= 120 - 2) {
      valSet1 = true;
      valArray1 = false;
      for (uint8_t i = 1; i < 99; i++) {
        storage1[i] = 255;
      }
      storeNum1 = 0;
    }
    peakVal1 = peakVal1 - 130;

    if (peakVal1 >= 100) {
      peakVal1 = 100;
    }
    if (peakVal1 <= 0 && peakVal1 > -8) {
      peakVal1 = 0;
    }

    if (disconnected == false) {
      if (valArray1 == true && valSet1 == false) {
        if (collectTotalVals1 == true) {
          for (int i = 0; i < 10; i++) {
            if (peakVal1 >= (i * 10) - 2 && peakVal1 <= (i * 10) + 2) {
              totalVals1[storeTotalVals1 - 1] = i;
            }
          }
          if (storeTotalVals1 == 2) {
            totalVals1[2] = (totalVals1[0] * 10) + totalVals1[1];
            collectTotalVals1 = false;
            storeTotalVals1 = 0;
            for (uint8_t i = totalVals1[2]; i < 99; i++) {
              storage1[i] = 255;
            }
          }
        } else {
          if (peakVal1 >= 0 && peakVal1 <= 100) {
            storage1[storeNum1] = peakVal1;
          }
        }
      }
      if (valSet1 == true && valArray1 == false) {
        storeNum1 = 0;
        if (peakVal1 >= 0 && peakVal1 <= 100) {
          storage1[storeNum1] = peakVal1;
        }
      }
    }

  }

  if (disconnected == false) {
    if (valSet1 == false && valArray1 == false) {
      storeNum1 = 0;
      storage1[storeNum1] = peakVal1;
    }
  }

  if (disconnectCount > 50) {
    disconnectCount = 60;
    analogWrite(ledPin, 255);
    disconnected = true;
    valArray1 = false;
    valSet1 = false;
    storeNum1 = 0;
    for (uint8_t i = 1; i < 99; i++) {
      storage1[i] = 255;
    }
    storage1[0] = 100;
  }

  for (uint8_t i = 98; i > 0; i--) {
    if (storage1[i] == 255) {
      store1Count = i - 1;
    }
  }

  if (playNum > store1Count) {
    playNum = 0;
  }

  if (storage1[0] == 255) {
    ledCommand = 255;
  } else {
    if (store1Count == 0) {
      ledCommand = (int) map(storage1[0], 0, 100, 0, 255);
    } else {
      if (cycleCountDelay < speedVal) { //Repeat this for as many times as the length says
        ledCommand = (int) map(storage1[playNum], 0, 100, 0, 255); //Scale from 0-100 to 0-255
      } else {
        cycleCountDelay = 0;
        playNum++;
      }
    }
  }

  //Only call the analogWrite if there is a significantly different value to send
  if (lastCommand > ledCommand + 1 || lastCommand < ledCommand - 1) {
    newVal = true;
  } else {
    newVal = false;
  }

  if (newVal == true) {
    analogWrite(ledPin, ledCommand);
    lastCommand = ledCommand;
  }

  delay(10);
}
