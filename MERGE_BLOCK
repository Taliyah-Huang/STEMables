const int RX_PIN1 = A1;
const int RX_PIN2 = A2;
const int RX_PIN3 = A3;
const int TX_PIN1 = 0;

int cycleCountDelay = 0;
int playNum;
int TX_Val;
int totalStore [12] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int totalStoreCount = -1;
bool playType = false;

int currentRead1 = 0;
int true1Count = 0;
int storage1 [12] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int store1Count = -1;
int averages1[5] = {0, 0, 0, 0, 0};
int totalAve1 = 0;
int trueVals1[2] = {0, 0};
float trueVal1 = 0.0;
int peakVal1 = 0;
float remainder1 = 0.0;
int storeNum1 = 0;
bool channel1 = false;
int channel1Count = 0;
bool reset1 = false;
int trueFalseCount1 = 0;

int currentRead2 = 0;
int true2Count = 0;
int storage2 [12] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int store2Count = -1;
int averages2[5] = {0, 0, 0, 0, 0};
int totalAve2 = 0;
int trueVals2[2] = {0, 0};
float trueVal2 = 0.0;
int peakVal2 = 0;
float remainder2 = 0.0;
int storeNum2 = 0;
bool channel2 = false;
int channel2Count = 0;
bool reset2 = false;
int trueFalseCount2 = 0;

int currentRead3 = 0;
int true3Count = 0;
int storage3 [12] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int store3Count = -1;
int averages3[5] = {0, 0, 0, 0, 0};
int totalAve3 = 0;
int trueVals3[2] = {0, 0};
float trueVal3 = 0.0;
int peakVal3 = 0;
float remainder3 = 0.0;
int storeNum3 = 0;
bool channel3 = false;
int channel3Count = 0;
bool reset3 = false;
int trueFalseCount3 = 0;

const int inputVal[13] = {1, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 50, 101};
const float scaleVal[13] = {6.0, 5.0, 4.67, 4.5, 4.4, 4.33, 4.25, 4.2, 4.13, 4.1, 4.03, 4.02, 4.0};
const int finalVal[13] = {6, 10, 14, 18, 22, 26, 34, 42, 62, 82, 121, 201, 405};

void setup() {
  pinMode(TX_PIN1, OUTPUT);
  pinMode(RX_PIN1, INPUT);
  pinMode(RX_PIN2, INPUT);
  pinMode(RX_PIN3, INPUT);
}

void loop() {
  cycleCountDelay++;
  currentRead1 = analogRead(RX_PIN1);
  currentRead2 = analogRead(RX_PIN2);
  currentRead3 = analogRead(RX_PIN3);

  //Count channel disconnected
  if (channel1 == false) {
    channel1Count++;
  } else {
    if (channel1Count != 0) {
      channel1Count = 0;
    }
  }

  if (channel2 == false) {
    channel2Count++;
  } else {
    if (channel2Count != 0) {
      channel2Count = 0;
    }
  }

  if (channel3 == false) {
    channel3Count++;
  } else {
    if (channel3Count != 0) {
      channel3Count = 0;
    }
  }

  channel1 = false;
  channel2 = false;
  channel3 = false;

  //Running average of analogRead values
  for (int i = 4; i > 0; i--) {
    averages1[i] = averages1[i - 1];
    averages2[i] = averages2[i - 1];
    averages3[i] = averages3[i - 1];
  }
  averages1[0] = currentRead1;
  averages2[0] = currentRead2;
  averages3[0] = currentRead3;

  totalAve1 = (averages1[4] + averages1[3] + averages1[2] + averages1[1] + averages1[0]) / 5;
  totalAve2 = (averages2[4] + averages2[3] + averages2[2] + averages2[1] + averages2[0]) / 5;
  totalAve3 = (averages3[4] + averages3[3] + averages3[2] + averages3[1] + averages3[0]) / 5;

  //Scale from raw analog to 0-255
  for (int i = 0; i < 12; i++) {
    if (totalAve1 >= finalVal[i] - 2 && totalAve1 <= finalVal[i + 1] - 2) {
      trueVal1 = totalAve1 / (int) map(totalAve1, finalVal[i], finalVal[i + 1], scaleVal[i], scaleVal[i + 1]);
    }
    if (totalAve2 >= finalVal[i] - 2 && totalAve2 <= finalVal[i + 1] - 2) {
      trueVal2 = totalAve2 / (int) map(totalAve2, finalVal[i], finalVal[i + 1], scaleVal[i], scaleVal[i + 1]);
    }
    if (totalAve3 >= finalVal[i] - 2 && totalAve3 <= finalVal[i + 1] - 2) {
      trueVal3 = totalAve3 / (int) map(totalAve3, finalVal[i], finalVal[i + 1], scaleVal[i], scaleVal[i + 1]);
    }
  }

  //Anything greater than or equal to the value for 101 will be divided by 4
  if (totalAve1 >= finalVal[12]) {
    trueVal1 = totalAve1 / scaleVal[12];
  }
  if (totalAve2 >= finalVal[12]) {
    trueVal2 = totalAve2 / scaleVal[12];
  }
  if (totalAve3 >= finalVal[12]) {
    trueVal3 = totalAve3 / scaleVal[12];
  }

  //Anything between 100~120 will be 100
  if (totalAve1 >= 400 && totalAve1 <= 435) {
    trueVal1 = 100.0;
  }
  if (totalAve2 >= 400 && totalAve2 <= 435) {
    trueVal2 = 100.0;
  }
  if (totalAve3 >= 400 && totalAve3 <= 435) {
    trueVal3 = 100.0;
  }

  //Round the value by 0.5
  remainder1 = (float) trueVal1 - (int) trueVal1;
  remainder2 = (float) trueVal2 - (int) trueVal2;
  remainder3 = (float) trueVal3 - (int) trueVal3;

  trueVal1 = (int) trueVal1;
  trueVal2 = (int) trueVal2;
  trueVal3 = (int) trueVal3;

  if (remainder1 >= 0.5) {
    trueVal1++;
  }
  if (remainder2 >= 0.5) {
    trueVal2++;
  }
  if (remainder3 >= 0.5) {
    trueVal3++;
  }

  //Holding 2 values
  trueVals1[1] = trueVals1[0];
  trueVals2[1] = trueVals2[0];
  trueVals3[1] = trueVals3[0];

  trueVals1[0] = trueVal1;
  trueVals2[0] = trueVal2;
  trueVals3[0] = trueVal3;

  //Count the number of "repeated" values
  if (trueVals1[0] >= trueVals1[1] - 2 && trueVals1[0] <= trueVals1[1] + 2) {
    true1Count++;
  } else {
    if (true1Count != 0) {
      true1Count = 0;
    }
  }

  if (trueVals2[0] >= trueVals2[1] - 2 && trueVals2[0] <= trueVals2[1] + 2) {
    true2Count++;
  } else {
    if (true2Count != 0) {
      true2Count = 0;
    }
  }

  if (trueVals3[0] >= trueVals3[1] - 2 && trueVals3[0] <= trueVals3[1] + 2) {
    true3Count++;
  } else {
    if (true3Count != 0) {
      true3Count = 0;
    }
  }

  //Collect the most closest value once
  if (true1Count == 10) {
    peakVal1 = trueVals1[0];
  }
  if (true2Count == 10) {
    peakVal2 = trueVals2[0];
  }
  if (true3Count == 10) {
    peakVal3 = trueVals3[0];
  }

  if (true1Count == 0 || true1Count == 1) {
    trueFalseCount1++;
  } else {
    trueFalseCount1 = 0;
  }

  if (true2Count == 0 || true2Count == 1) {
    trueFalseCount2++;
  } else {
    trueFalseCount2 = 0;
  }

  if (true3Count == 0 || true3Count == 1) {
    trueFalseCount3++;
  } else {
    trueFalseCount3 = 0;
  }

  for (int i = 0; i < 12; i++) {
    if (peakVal1 >= (120 + (i * 10)) - 4 && peakVal1 <= (120 + (i * 10)) + 4) {
      storeNum1 = i;
      channel1 = true;
      peakVal1 = (120 + (i * 10));
    }
  }

  for (int i = 0; i < 12; i++) {
    if (peakVal2 >= (120 + (i * 10)) - 4 && peakVal2 <= (120 + (i * 10)) + 4) {
      storeNum2 = i;
      channel2 = true;
      peakVal2 = (120 + (i * 10));
    }
  }

  for (int i = 0; i < 12; i++) {
    if (peakVal3 >= (120 + (i * 10)) - 4 && peakVal3 <= (120 + (i * 10)) + 4) {
      storeNum3 = i;
      channel3 = true;
      peakVal3 = (120 + (i * 10));
    }
  }

  if (trueFalseCount1 > 100) {
    channel1 = false;
  }

  if (trueFalseCount2 > 100) {
    channel2 = false;
  }

  if (trueFalseCount3 > 100) {
    channel3 = false;
  }

  if (channel1Count >= 100) {
    for (int i = 0; i < 12; i++) {
      storage1[i] = -1;
    }
    store1Count = -1;
    peakVal1 = -1;
    storeNum1 = 0;
  } else {

    //If it is 0-100, collect the value into the storage
    if (peakVal1 <= 105) {
      if (peakVal1 == 100) {
        storage1[storeNum1] = 105;
      } else {
        storage1[storeNum1] = peakVal1;
      }
    }

    if (peakVal1 >= 240 - 2 && peakVal1 <= 250 + 2) {
      storage1[storeNum1] = 250;
    }

    for (int i = 11; i >= 0; i--) {
      if (storage1[i] == -1) {
        store1Count = i - 1;
      }
    }

  }

  if (channel2Count >= 100) {
    for (int i = 0; i < 12; i++) {
      storage2[i] = -1;
    }
    store2Count = -1;
    peakVal2 = -1;
    storeNum2 = 0;
  } else {

    //If it is 0-100, collect the value into the storage
    if (peakVal2 <= 105) {
      if (peakVal2 == 100) {
        storage2[storeNum2] = 105;
      } else {
        storage2[storeNum2] = peakVal2;
      }
    }

    if (peakVal2 >= 240 - 2 && peakVal2 <= 250 + 2) {
      storage2[storeNum2] = 250;
    }

    for (int i = 11; i >= 0; i--) {
      if (storage2[i] == -1) {
        store2Count = i - 1;
      }
    }

  }

  if (channel3Count >= 100) {
    for (int i = 0; i < 12; i++) {
      storage3[i] = -1;
    }
    store3Count = -1;
    peakVal3 = -1;
    storeNum3 = 0;
  } else {

    //If it is 0-100, collect the value into the storage
    if (peakVal3 <= 105) {
      if (peakVal3 == 100) {
        storage3[storeNum3] = 105;
      } else {
        storage3[storeNum3] = peakVal3;
      }
    }

    if (peakVal3 >= 240 - 2 && peakVal3 <= 250 + 2) {
      storage3[storeNum3] = 250;
    }

    for (int i = 11; i >= 0; i--) {
      if (storage3[i] == -1) {
        store3Count = i - 1;
      }
    }

  }

  //Clear the totalStore
  for (int i = 0; i < 12; i++) {
    totalStore[i] = -1;
  }

  if (store1Count != -1) {
    for (int i = 0; i < 12; i++) {
      if (storage1[i] != -1) {
        totalStore[i] = storage1[i];
      }
    }
  }

  //Recalculate totalStoreCount
  for (int i = 11; i >= 0; i--) {
    if (totalStore[i] == -1) {
      totalStoreCount = i - 1;
    }
  }

  if (totalStoreCount < 12) {
    if (store2Count != -1) {
      for (int i = 0; i < 12; i++) {
        if (storage2[i] != -1) {
          totalStore[i + store1Count + 1] = storage2[i];
        }
      }
    }
  }

  //Recalculate totalStoreCount
  for (int i = 11; i >= 0; i--) {
    if (totalStore[i] == -1) {
      totalStoreCount = i - 1;
    }
  }

  if (totalStoreCount < 12) {
    if (store3Count != -1) {
      for (int i = 0; i < 12; i++) {
        if (storage3[i] != -1) {
          totalStore[i + store1Count + store2Count + 2] = storage3[i];
        }
      }
    }
  }

  //Recalculate totalStoreCount
  for (int i = 11; i >= 0; i--) {
    if (totalStore[i] == -1) {
      totalStoreCount = i - 1;
    }
  }

  if (playType == false) {
    if (cycleCountDelay < 25) {
      TX_Val = 120 + (playNum * 10);
    } else {
      cycleCountDelay = 0;
      playType = true;
    }
  } else {
    if (cycleCountDelay < 25) {
      TX_Val = totalStore[playNum];
    } else {
      cycleCountDelay = 0;
      playType = false;
      playNum++;
    }
  }

  if (playNum > totalStoreCount) {
    playNum = 0;
  }

  analogWrite(TX_Val, TX_PIN1);

  delay(10);
}
