const int RX_PIN1 = A1;
const int TX_PIN1 = 0;
const int ledPin = 1;

const int inputVal[12] = {1, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 50};
const float scaleVal[12] = {6.0, 5.0, 4.67, 4.5, 4.4, 4.33, 4.25, 4.2, 4.13, 4.1, 4.03, 4.02};
const int finalVal[12] = {6, 10, 14, 18, 22, 26, 34, 42, 62, 82, 121, 201};

int averages1[5] = {0, 0, 0, 0, 0};
int totalAve1 = 0;
int trueVals1[8] = {0, 0, 0, 0, 0, 0, 0, 0};
bool channel1 = false;
bool channel1Vals[5] = {false, false, false, false, false};
float trueVal1 = 0.0;
float remainder1 = 0.0;

int cycleCountChannel = 0;
int cycleCountTX = 0;
bool TX_Type = false;

int brightness = 0;
int convertedBrightness = 0;

void setup() {
  pinMode(RX_PIN1, INPUT);
  pinMode(TX_PIN1, OUTPUT);
  pinMode(ledPin, OUTPUT);
}

void loop() {
  cycleCountChannel++;
  cycleCountTX++;

  //Record the channel state every 8 cycles
  if (cycleCountChannel == 8) {
    for (int i = 4; i > 0; i--) {
      channel1Vals[i] = channel1Vals[i - 1];
    }
    channel1Vals[0] = channel1;
    cycleCountChannel = 0;
  }

  //Save 5 values for the running average
  for (int i = 4; i > 0; i--) {
    averages1[i] = averages1[i - 1];
  }

  //Save past 8 values
  for (int i = 7; i > 0; i--) {
    trueVals1[i] = trueVals1[i - 1];
  }

  if (channel1 == false) {
    if (analogRead(RX_PIN1) >= 480) {
      channel1 = true;
    }
  }

  if (channel1 == true) {
    averages1[0] = analogRead(RX_PIN1);
  }

  totalAve1 = (averages1[4] + averages1[3] + averages1[2] + averages1[1] + averages1[0]) / 5;

  //Scale the received analog input to a number between 0 and 100
  for (int i = 0; i < 11; i++) {
    if (totalAve1 >= finalVal[i] - 2 && totalAve1 <= finalVal[i + 1] - 2) {
      trueVal1 = totalAve1 / (int) map(totalAve1, finalVal[i], finalVal[i + 1], scaleVal[i], scaleVal[i + 1]);
    }
  }

  //If the input is 4 or less, the value is 0
  if (totalAve1 <= 4) {
    trueVal1 = 0.0;
  }

  //If the input is more than 201, the scaling is 4.02
  if (totalAve1 >= finalVal[11]) {
    trueVal1 = totalAve1 / scaleVal[11];
  }

  //If the input is more than 402, stop at 100
  if (totalAve1 >= 402) {
    trueVal1 = 100;
  }

  //Rounding
  remainder1 = (float) trueVal1 - (int) trueVal1;

  if (remainder1 >= 0.5) {
    trueVal1 = (int) trueVal1;
    trueVal1++;
  }

  if (remainder1 < 0.5) {
    trueVal1 = (int) trueVal1;
  }

  trueVals1[0] = trueVal1;

  if (channel1 == true && analogRead(RX_PIN1) <= 480 && averages1[0] >= averages1[1] - 5 && averages1[0] <= averages1[1] + 5 && averages1[1] >= averages1[2] - 5 && averages1[1] <= averages1[2] + 5 && averages1[2] >= averages1[3] - 5 && averages1[1] <= averages1[2] + 5 && averages1[3] >= averages1[4] - 5 && averages1[3] <= averages1[4] + 5 && trueVals1[0] == trueVals1[1] && trueVals1[1] == trueVals1[2] && trueVals1[2] == trueVals1[3] && trueVals1[3] == trueVals1[4] && trueVals1[4] == trueVals1[5] && trueVals1[5] == trueVals1[6] && trueVals1[6] == trueVals1[7]) {
    brightness = trueVal1;
    channel1 = false;
  }

  if (channel1Vals[0] == false && channel1Vals[1] == false && channel1Vals[2] == false && channel1Vals[3] == false && channel1Vals[4] == false) {
    brightness = 100; //Set the brightness to default 100 if no number is connected
  }

  convertedBrightness = (int) ((255 * brightness) / 100);
  analogWrite(ledPin, convertedBrightness);

  //Project the received data to the next module connected directly to LED
  if (TX_Type == false) {
    if (cycleCountTX < 15) { //Send channel signal for 300ms
      analogWrite(TX_PIN1, 150);
    } else {
      cycleCountTX = 0;
      TX_Type = true;
    }
  } else {
    if (cycleCountTX < 50) { //Send brightness for 1000ms
      analogWrite(TX_PIN1, brightness);
    } else {
      cycleCountTX = 0;
      TX_Type = false;
    }
  }

  delay(20);
}
